"use strict";

var chokidar = require(`chokidar`);

var _require = require(`./create-file-node`),
    createId = _require.createId,
    createFileNode = _require.createFileNode;

exports.sourceNodes = function (_ref, pluginOptions, done) {
  var boundActionCreators = _ref.boundActionCreators,
      getNode = _ref.getNode,
      hasNodeChanged = _ref.hasNodeChanged;
  var createNode = boundActionCreators.createNode,
      deleteNode = boundActionCreators.deleteNode;


  var ready = false;

  var watcher = chokidar.watch(pluginOptions.path, {
    ignored: [`**/*.un~`, `**/.gitignore`, `**/.npmignore`, `**/.babelrc`, `**/yarn.lock`, `**/node_modules`, `../**/dist/**`]
  });

  // For every path that is reported before the 'ready' event, we throw them
  // into a queue and then flush the queue when 'ready' event arrives.
  // After 'ready', we handle the 'add' event without putting it into a queue.
  var pathQueue = [];
  var flushPathQueue = function flushPathQueue(onComplete) {
    var queue = pathQueue;
    pathQueue = [];

    var numPathsProcessed = 0;
    var numPaths = queue.length;

    queue.forEach(function (path) {
      createFileNode(path, pluginOptions, function (err, file) {
        createNode(file);

        numPathsProcessed++;
        if (numPathsProcessed === numPaths) {
          onComplete();
        }
      });
    });
  };

  watcher.on(`add`, function (path) {
    if (ready) {
      console.log(`added file at`, path);
      createFileNode(path, pluginOptions, function (err, file) {
        createNode(file);
      });
    } else {
      pathQueue.push(path);
    }
  });
  watcher.on(`change`, function (path) {
    console.log(`changed file at`, path);
    createFileNode(path, pluginOptions, function (err, file) {
      createNode(file);
    });
  });
  watcher.on(`unlink`, function (path) {
    console.log(`file deleted at`, path);
    var node = getNode(createId(path));
    deleteNode(node.id, node);

    // Also delete nodes for the file's transformed children nodes.
    node.children.forEach(function (childId) {
      return deleteNode(childId, getNode(childId));
    });
  });
  watcher.on(`ready`, function () {
    if (ready) {
      return;
    }

    ready = true;
    flushPathQueue(function () {
      done();
    });
  });

  return;
};